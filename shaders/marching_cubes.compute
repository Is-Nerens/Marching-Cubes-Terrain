#version 460 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Uniforms
uniform float densityThreshold;
uniform int width;
uniform int height;
uniform int offsetX;
uniform int offsetY;
uniform int offsetZ;

layout(binding = 0) readonly buffer VolumeDataBuffer {
    float VolumeData[];
};
layout(binding = 1) writeonly buffer VertexBuffer {
    float vertices[];
};
layout(binding = 2) readonly buffer TriTableBuffer {
    int TriTable[];
};


// cornerIndexAFromEdge array
const int cornerIndexAFromEdge[12] = int[](0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3);

// cornerIndexBFromEdge array
const int cornerIndexBFromEdge[12] = int[](1, 2, 3, 0, 5, 6, 7, 4, 4, 5, 6, 7);


struct Corner {
    vec3 position;
    float density;
};

vec3 VertexInterp(Corner c1, Corner c2)
{
    float t = (densityThreshold- c1.density) / (c2.density - c1.density);
    vec3 v;
    v.x = c1.position.x + t * (c2.position.x - c1.position.x);
    v.y = c1.position.y + t * (c2.position.y - c1.position.y);
    v.z = c1.position.z + t * (c2.position.z - c1.position.z);
    return v;
}

vec3 CalculateNormal(vec3 v1, vec3 v2, vec3 v3)
{
    vec3 vect1 = v2 - v1;
    vec3 vect2 = v3 - v1;
    
    // Handle degenerate case, return a default normal 
    if (length(vect1) < 0.00001 || length(vect2) < 0.00001) {
        return vec3(0.0, 0.0, 0.0); 
    }
    
    vec3 unnormalized = cross(vect1, vect2);
    return normalize(unnormalized);
}

float GetDensity(float xF, float yF, float zF)
{
    int x = int(floor(xF + 0.5));
    int y = int(floor(yF + 0.5));
    int z = int(floor(zF + 0.5));
    int index = z + (width+1) * (x + (height+1) * y);
    return VolumeData[index];
}

int TriTableGet(int cubeIndex, int i)
{
    int index = cubeIndex * 16 + i;
    return TriTable[index];
}

void AddFace(vec3 v1, vec3 v2, vec3 v3, vec3 normal, int index)
{
    // vertex 1
    vertices[index]     = v1.x + offsetX;
    vertices[index + 1] = v1.y + offsetY;
    vertices[index + 2] = v1.z + offsetZ;

    // vertex 2
    vertices[index + 3] = v2.x + offsetX;
    vertices[index + 4] = v2.y + offsetY;
    vertices[index + 5] = v2.z + offsetZ;

    // vertex 3
    vertices[index + 6] = v3.x + offsetX;
    vertices[index + 7] = v3.y + offsetY;
    vertices[index + 8] = v3.z + offsetZ;

    // normal
    vertices[index + 9] = normal.x;
    vertices[index + 10] = normal.y;
    vertices[index + 11] = normal.z;
}


void main()
{
    int threadID = int(gl_GlobalInvocationID.x) +
               int(gl_GlobalInvocationID.y) * int(gl_NumWorkGroups.x) * int(gl_WorkGroupSize.x) +
               int(gl_GlobalInvocationID.z) * int(gl_NumWorkGroups.x) * int(gl_NumWorkGroups.y) * int(gl_WorkGroupSize.x) * int(gl_WorkGroupSize.y);

    // create 8 corners
    Corner corners[8];
    corners[0].position = vec3(gl_GlobalInvocationID.x - 0.5, gl_GlobalInvocationID.y - 0.5, gl_GlobalInvocationID.z + 0.5);
    corners[1].position = vec3(gl_GlobalInvocationID.x + 0.5, gl_GlobalInvocationID.y - 0.5, gl_GlobalInvocationID.z + 0.5);
    corners[2].position = vec3(gl_GlobalInvocationID.x + 0.5, gl_GlobalInvocationID.y - 0.5, gl_GlobalInvocationID.z - 0.5);
    corners[3].position = vec3(gl_GlobalInvocationID.x - 0.5, gl_GlobalInvocationID.y - 0.5, gl_GlobalInvocationID.z - 0.5);
    corners[4].position = vec3(gl_GlobalInvocationID.x - 0.5, gl_GlobalInvocationID.y + 0.5, gl_GlobalInvocationID.z + 0.5);
    corners[5].position = vec3(gl_GlobalInvocationID.x + 0.5, gl_GlobalInvocationID.y + 0.5, gl_GlobalInvocationID.z + 0.5);
    corners[6].position = vec3(gl_GlobalInvocationID.x + 0.5, gl_GlobalInvocationID.y + 0.5, gl_GlobalInvocationID.z - 0.5);
    corners[7].position = vec3(gl_GlobalInvocationID.x - 0.5, gl_GlobalInvocationID.y + 0.5, gl_GlobalInvocationID.z - 0.5);

    // calculate the cube index
    int cubeIndex = 0;
    for (int i = 0; i < 8; ++i) {
        corners[i].density = GetDensity(corners[i].position.x, corners[i].position.y, corners[i].position.z);
        if (corners[i].density > densityThreshold) cubeIndex |= (1 << i);
    }

    // Fill cubeVertices and cubeNormals arrays
    int i = 0;
    while(TriTableGet(cubeIndex, i) != -1)
    {    
        int a0 = cornerIndexAFromEdge[TriTableGet(cubeIndex, i)];
        int b0 = cornerIndexBFromEdge[TriTableGet(cubeIndex, i)];
        int a1 = cornerIndexAFromEdge[TriTableGet(cubeIndex, i+1)];
        int b1 = cornerIndexBFromEdge[TriTableGet(cubeIndex, i+1)];
        int a2 = cornerIndexAFromEdge[TriTableGet(cubeIndex, i+2)];
        int b2 = cornerIndexBFromEdge[TriTableGet(cubeIndex, i+2)];
        
        vec3 v1 = VertexInterp(corners[a0], corners[b0]);
        vec3 v2 = VertexInterp(corners[a1], corners[b1]);
        vec3 v3 = VertexInterp(corners[a2], corners[b2]);
        vec3 normal = CalculateNormal(v1, v2, v3);

        AddFace(v1, v2, v3, normal, threadID * 48 + i * 4);
        i += 3;
    }
}









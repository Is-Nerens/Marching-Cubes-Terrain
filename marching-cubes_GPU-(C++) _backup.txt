#ifndef MARCHING_CUBES_GPU_H
#define MARCHING_CUBES_GPU_H

#include "vendor/glm/glm.hpp"
#include "tables.h"
#include "model.h"
#include "shader.h"
#include "error.h"
#include "FastNoiseLite.h"
#include <vector>
#include <GL/glew.h>
#include <unordered_map>
#include <iostream>
#include <functional>
#include <algorithm>
#include <string>
#include <tuple>

// Tritable is loaded correctly


class TerrainGPU{
public:

	TerrainGPU()
	{
        // Load shaders from file
        std::string compShaderSource = LoadShader("./shaders/marching_cubes.compute");
        computeShaderProgram = CreateComputeShader(compShaderSource);

        // load once
        TriTableValues = LoadTriTableValues();
        VertexHashMap = GenerateVertexHashMap();
        VertexHashMapKeys = GenerateVertexHashMapKeys();


		InitNoiseGenerator();
	}

	Model ConstructMeshGPU()
	{
        glUseProgram(computeShaderProgram);

		Model model;
        std::vector<float> VolumeData = GenerateVolume();
        std::vector<float> Vertices;
        std::vector<unsigned int> Indices;
        std::vector<int> Counts;
        Counts.push_back(0);
        Counts.push_back(0);


        if (GetShaderProgramInUse() == computeShaderProgram)
        {
            std::cout << "correct shader program used" << std::endl;
        }



        // passing data to the shader via uniforms
        offset = 0; // i need to fix the width stuff
        int locc = BindUniformFloat1(computeShaderProgram, "densityThreshold", densityThreshold);
        BindUniformInt1(computeShaderProgram, "width", width);
        BindUniformInt1(computeShaderProgram, "height", height);
        BindUniformInt1(computeShaderProgram, "offset", offset);
        PrintGLErrors();

        // -----------------------------
        // Send data to the GPU
        // -----------------------------
        GLuint vbo1, vbo2, vbo3, vbo4, vbo5, vbo6, vbo7; 

        // Bind buffer for the first vector (VolumeData)
        glGenBuffers(1, &vbo1);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, vbo1);
        glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(float) * VolumeData.size(), VolumeData.data(), GL_STATIC_READ);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, vbo1);

        // Bind buffer for VertexHashMap
        glGenBuffers(1, &vbo2);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, vbo2);
        glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(int) * VertexHashMap.size(), VertexHashMap.data(), GL_DYNAMIC_DRAW);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, vbo2);

        // Bind buffer VertexHashMapKeys
        glGenBuffers(1, &vbo3);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, vbo3);
        glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(float) * VertexHashMapKeys.size(), VertexHashMapKeys.data(), GL_DYNAMIC_DRAW);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, vbo3);

        // Bind buffer Vertices
        glGenBuffers(1, &vbo4);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, vbo4);
        size_t vertexBufferSize = static_cast<size_t>((width + 1) * (height + 1) * 12 * sizeof(float)); // for vertices
        glBufferData(GL_SHADER_STORAGE_BUFFER, vertexBufferSize, nullptr, GL_DYNAMIC_DRAW); // Allocate space without initializing data
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, vbo4);

        // Bind buffer for Indices
        glGenBuffers(1, &vbo5);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, vbo5);
        size_t indexBufferSize = static_cast<size_t>((width + 1) * (height + 1) * 12 * sizeof(unsigned int)); // for indices
        glBufferData(GL_SHADER_STORAGE_BUFFER, indexBufferSize, nullptr, GL_DYNAMIC_DRAW); // Allocate space without initializing data
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 4, vbo5);

        // Bind buffer for Counts
        glGenBuffers(1, &vbo6);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, vbo6);
        glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(int) * 2, Counts.data(), GL_DYNAMIC_DRAW); 
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 5, vbo6);

        // Bind buffer for TriTable
        glGenBuffers(1, &vbo7);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, vbo7);
        glBufferData(GL_SHADER_STORAGE_BUFFER, sizeof(int) * 4096, TriTableValues.data(), GL_STATIC_READ); 
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 6, vbo7);

        // Atomic flag
        GLuint atomicFlagBuffer;
        GLuint initialAtomicValue = 0; // Initial value for the atomic integer
        glGenBuffers(1, &atomicFlagBuffer);
        glBindBuffer(GL_ATOMIC_COUNTER_BUFFER, atomicFlagBuffer);
        glBufferData(GL_ATOMIC_COUNTER_BUFFER, sizeof(GLuint), &initialAtomicValue, GL_DYNAMIC_DRAW);
        glBindBufferBase(GL_ATOMIC_COUNTER_BUFFER, 7, atomicFlagBuffer);
        GLuint *ptr = (GLuint*)glMapBuffer(GL_ATOMIC_COUNTER_BUFFER, GL_READ_WRITE);
        *ptr = 0; // Initialize counter value
        glUnmapBuffer(GL_ATOMIC_COUNTER_BUFFER);
 


        glUseProgram(computeShaderProgram);
        glDispatchCompute(width, height, width);
        glMemoryBarrier(GL_ALL_BARRIER_BITS);
        glFinish();



        // Copy counts data from GPU to CPU
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, vbo6);
        GLint* countsDataPtr = nullptr;
        countsDataPtr = (GLint*)glMapBuffer(GL_SHADER_STORAGE_BUFFER, GL_READ_ONLY);
        if (countsDataPtr) {
            Counts.assign(countsDataPtr, countsDataPtr + 2);
            glUnmapBuffer(GL_SHADER_STORAGE_BUFFER);
        }

        // Copy vertex data from GPU to CPU
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, vbo4); 
        GLfloat* verticesDataPtr = nullptr;
        verticesDataPtr = (GLfloat*)glMapBuffer(GL_SHADER_STORAGE_BUFFER, GL_READ_ONLY);
        if (verticesDataPtr) {
            Vertices.assign(verticesDataPtr, verticesDataPtr + Counts[0] * 6);
            glUnmapBuffer(GL_SHADER_STORAGE_BUFFER);
        }

        // Copy index data from GPU to CPU
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, vbo5); 
        GLint* indicesDataPtr = nullptr;
        indicesDataPtr = (GLint*)glMapBuffer(GL_SHADER_STORAGE_BUFFER, GL_READ_ONLY);
        if (indicesDataPtr) {
            Indices.assign(indicesDataPtr, indicesDataPtr + Counts[1]);
            glUnmapBuffer(GL_SHADER_STORAGE_BUFFER);
        }

        // Cleanup
        glDeleteBuffers(1, &vbo1);
        glDeleteBuffers(1, &vbo2);
        glDeleteBuffers(1, &vbo3);
        glDeleteBuffers(1, &vbo4);
        glDeleteBuffers(1, &vbo5);
        glDeleteBuffers(1, &vbo6);
        glDeleteBuffers(1, &vbo7);

        model.vertices = Vertices;
        model.indices = Indices;
        std::cout << "vertex count (counter): " << Counts[0] << ", model vertices count: " <<  model.VertexCount() << std::endl;
        std::cout << "index count (counter): " << Counts[1] << ", model indices count: " <<  model.indices.size() << std::endl;
        // for (int i=0; i<model.vertices.size(); ++i)
        // {
        //     std::cout << model.vertices[i] << " " ;
        // }



        std::cout << " " << std::endl;
        std::cout << " " << std::endl;
        std::cout << " " << std::endl;
        std::cout << " " << std::endl;
        // for (int i=0; i<model.indices.size(); ++i)
        // {
        //     std::cout << model.indices[i] << " " ;
        // }
        return model;
    }

private:

	int width = 64;
	int height = 64;
    int offset = 0;
    float densityThreshold = 0.6f;
    unsigned int computeShaderProgram;

    // load once for optimisation
    std::vector<int> TriTableValues;
    std::vector<int> VertexHashMap;
    std::vector<float> VertexHashMapKeys;

	std::unordered_map<std::tuple<float, float, float>, float> editsHashMap;
	FastNoiseLite noiseGenerator3D;
	FastNoiseLite noiseGenerator2D;

    std::vector<float> GenerateVolume()
    {
        std::vector<float> volume;
        for (int y = 0; y < height+1; ++y){
	        for (int x = 0; x < width+1; ++x){
	            for (int z = 0; z < width+1; ++z){
                    float density = GetVolume3D(x, y, z);
                    volume.push_back(density);
                }
            }
        }
        return volume;
    }

    std::vector<int> GenerateVertexHashMap()
    {
        int size = ((width+1) * (width+1) * (height+1));
        return std::vector<int>(size, -1);
    }

    std::vector<float> GenerateVertexHashMapKeys()
    {
        int count = ((width+1) * (width+1) * (height+1)) * 3;
        return std::vector<float>(count, 1000.0f);
    }


	float GetVolume3D(float x, float y, float z)
	{
		int octaves = 6;
    	float amplitude = 1.0f;
		float prominance = 0.4f;
		float frequency = 1.0f;
		float totalNoise = 0.0f;
		for (int i = 0; i < octaves; i++) 
		{
        	totalNoise += noiseGenerator3D.GetNoise((x - offset) * frequency, y * frequency, (z-offset) * frequency) * amplitude;
        	frequency *= 2.0f;  // increase the frequency for each octave
        	amplitude *= prominance;  // decrease the amplitude for each octave
    	}
		return (totalNoise + 1) / 2.0f;
	}

	float GetNoise2D(float x, float y) 
	{
		int octaves = 3;
		float amplitude = 1.0f;
		float prominance = 0.4f;
		float frequency = 5.0f;
		float totalNoise = 0.0f;
		for (int i = 0; i < octaves; i++) 
		{
	    	totalNoise += noiseGenerator3D.GetNoise(x * frequency, y * frequency) * amplitude;
	    	frequency *= 2.0f;  // Increase the frequency for each octave
	    	amplitude *= prominance;  // Decrease the amplitude for each octave
		}
		return (totalNoise + 1) / 2.0f;
	}

	void InitNoiseGenerator()
	{
		noiseGenerator3D.SetNoiseType(FastNoiseLite::NoiseType_Perlin);
		noiseGenerator2D.SetNoiseType(FastNoiseLite::NoiseType_Perlin);
		noiseGenerator3D.SetSeed(1);
		noiseGenerator2D.SetSeed(1);
	}

    std::vector<int> LoadTriTableValues()
    {
        std::vector<int> data;
        for (int y=0; y<256; ++y)
        {
            for (int x=0; x< 16; ++x)
            {
                data.push_back(TriTable[y][x]);
            }
        }
        return data;
    }
};
#endif
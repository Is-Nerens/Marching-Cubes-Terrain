#pragma once
#include <unordered_map>
#include "marching_cubes_gpu.h"
#include "../vendor/glm/glm.hpp"
#include "../raycast.h"
#include "../model.h"
#include "../error.h"

struct TupleHash {
    template <class T1, class T2, class T3>
    std::size_t operator()(const std::tuple<T1, T2, T3>& tuple) const {
        auto h1 = std::hash<T1>{}(std::get<0>(tuple));
        auto h2 = std::hash<T2>{}(std::get<1>(tuple));
        auto h3 = std::hash<T3>{}(std::get<2>(tuple));
        return h1 ^ h2 ^ h3;
    }
}

class TerrainSystem
{
public:

    TerrainSystem()
    {
        terrainGPU.width = width;
        terrainGPU.height = height;
    }
    ~TerrainSystem() {}

    struct Chunk 
    {
        int x;
        int y;
        int z;
        bool regenerate = false;
        bool inRenderDist = true;
        std::vector<float> densities;
        ~Chunk() {
            densities.clear();
        }
    };

    std::vector<Model> models;

    void Update(float playerX, float playerY, float playerZ)
    {
        // COORDINATES OF CHUNK THAT BOUNDS THE PLAYER
        int minChunkX = (std::round(playerX / width)  * width)  -(renderDistanceH - 1) * width  / 2;
        int minChunkY = (std::round(playerY / height) * height) -(renderDistanceV - 1) * height / 2;
	    int minChunkZ = (std::round(playerZ / width)  * width)  -(renderDistanceH - 1) * width  / 2;
        int maxChunkX = minChunkX + renderDistanceH * width - 1;
        int maxChunkY = minChunkY + renderDistanceV * height - 1;
        int maxChunkZ = minChunkZ + renderDistanceH * width - 1;

        // GENERATE 8 CHUNKS PER FRAME
        int chunksGenerated = 0;

        // CHECK ALL CHUNKS TO SEE IF THEY ARE INSIDE RENDER DISTANCE
        for (int i=0; i<chunks.size(); ++i) {
            if (chunks[i].x >= minChunkX && chunks[i].x <= maxChunkX && 
                chunks[i].y >= minChunkY && chunks[i].y <= maxChunkY && 
                chunks[i].z >= minChunkZ && chunks[i].z <= maxChunkZ) 
            {
                chunks[i].inRenderDist = true;
            }
            else
            {
                chunks[i].inRenderDist = false;
            }
        }

        // REMOVE CHUNKS OUTSIDE RENDER DISTANCE
        for (int i=0; i<chunks.size(); ++i) {
            if (chunks[i].inRenderDist == false) {
                chunks.erase(chunks.begin() + i);
                models.erase(models.begin() + i);
                --i;
            } 
        }


        // GENERATE NEW CHUNKS || REGENERATE CHUNKS
        for (int y=0; y <renderDistanceV; ++y) {
            for (int x=0; x <renderDistanceH; ++x) {
                for (int z=0; z<renderDistanceH; ++z) {

                    Debug::StartTimer();
                    int chunkX = (x * width)  + minChunkX;
                    int chunkY = (y * height) + minChunkY;
                    int chunkZ = (z * width)  + minChunkZ;

                    // CHECK IF CHUNK EXISTS AT POSITION
                    bool chunkPresent = false;
                    for (int i=0; i<chunks.size(); ++i) 
                    {
                        if (chunks[i].x == chunkX && chunks[i].y == chunkY && chunks[i].z == chunkZ) 
                        {
                            chunkPresent = true;
                            
                            // REGENERATE CHUNK
                            if (chunks[i].regenerate)
                            {
                                models[i] = terrainGPU.ConstructMeshGPU(chunkX, chunkY, chunkZ, chunks[i].densities);
                                chunksGenerated += 1;
                                chunks[i].regenerate = false;
                            }
                        }
                    }

                    Debug::EndTimer();

                    // NO CHUNK AT LOCATION -> GENERATE ONE
                    if (!chunkPresent) 
                    {
                        std::cout << "here ";
                        Model model = terrainGPU.ConstructMeshGPU(chunkX, chunkY, chunkZ);
                        models.push_back(model);
                        Chunk newChunk;
                        newChunk.x = chunkX;
                        newChunk.y = chunkY;
                        newChunk.z = chunkZ;
                        newChunk.densities = std::vector<float>((width+1)*(width+1)*(height+1), 0.0f);
                        chunks.push_back(newChunk);
                        chunksGenerated += 1;
                    }

                    if (chunksGenerated >= 4) return;
                }
            }
        }
    }
    
    RayHit Raycast(glm::vec3 origin, glm::vec3 direction)
    {
        RayHit hit;
        Ray ray;
        ray.origin = origin;
        ray.direction = direction;
        float closestHit = 1000000.0f;

        // RAY, CHUNK BOUNDING BOX INTERSECTION TEST
        for (int i=0; i<chunks.size(); ++i)
        {   
            // CONSTRUCT CHUNK BOUNDING BOX
            float hWidth = width/2;
            float hHeight = height/2;
            glm::vec3 chunkBL = glm::vec3 {
                chunks[i].x - hWidth, 
                chunks[i].y - hHeight, 
                chunks[i].z - hWidth};
            BoundingBox boundingBox;
            boundingBox.min = chunkBL;
            boundingBox.max = chunkBL + glm::vec3(width, height, width);

            // IF RAY INTERSECTS CHUNK BOUNDING BOX, PERFORM RAY TRIANGLE INTERSECTIONS
            if (RayIntersectsBox(ray, boundingBox))
            {
                // LOOP OVER MODEL INDICES TO EXTRACT TRIANGLE VERTICES
                for (int k=0; k<models[i].indices.size(); k+=3) 
                {
                    int v1Index = models[i].indices[k + 0];
                    int v2Index = models[i].indices[k + 1];
                    int v3Index = models[i].indices[k + 2];
                    glm::vec3 v1 = glm::vec3{
                        models[i].vertices[v1Index * 6 + 0] + models[i].position.x, 
                        models[i].vertices[v1Index * 6 + 1] + models[i].position.y, 
                        models[i].vertices[v1Index * 6 + 2] + models[i].position.z};
                    glm::vec3 v2 = glm::vec3{
                        models[i].vertices[v2Index * 6 + 0] + models[i].position.x, 
                        models[i].vertices[v2Index * 6 + 1] + models[i].position.y, 
                        models[i].vertices[v2Index * 6 + 2] + models[i].position.z};
                    glm::vec3 v3 = glm::vec3{
                        models[i].vertices[v3Index * 6 + 0] + models[i].position.x, 
                        models[i].vertices[v3Index * 6 + 1] + models[i].position.y, 
                        models[i].vertices[v3Index * 6 + 2] + models[i].position.z};
                    
                    // RAY TRIANGLE INTERSECTION WITH EVERY FACE
                    RayHit newhit = RayTriangleIntersection(ray, v1, v2, v3);
                    if (newhit.hit) {
                        if (newhit.distance < closestHit) {
                            closestHit = newhit.distance;
                            hit = newhit;
                        }
                    }
                }
            }
        }
        return hit;
    }

    void AddDensity(glm::vec3& position, int radius, float amount) 
    {
        // snap position to grid
        int snapWorldX = std::round(position.x);
        int snapWorldY = std::round(position.y);
        int snapWorldZ = std::round(position.z);

        // std::cout << "snap pos: " << snapWorldX << " " << snapWorldY << " " << snapWorldZ << std::endl;

        // bounding box of the affected corners
        int minX = snapWorldX - radius;
        int maxX = snapWorldX + radius;
        int minY = snapWorldY - radius;
        int maxY = snapWorldY + radius;
        int minZ = snapWorldZ - radius;
        int maxZ = snapWorldZ + radius;
        
        // FOR EACH CHUNK
        for (int i = 0; i < chunks.size(); ++i) 
        {
            Chunk& chunk = chunks[i];

            // FOR EACH AFFECTED CORNER POSITION
            for (int x = minX; x < maxX; ++x) {
            for (int y = minY; y < maxY; ++y) {
            for (int z = minZ; z < maxZ; ++z) 
                    {
                        // CONVERT CORNER POSITION TO CHUNK LOCAL SPACE
                        int cornerLocalX = x - chunk.x + width/2;
                        int cornerLocalY = y - chunk.y + height/2;
                        int cornerLocalZ = z - chunk.z + width/2;

                        // IF CORNER POSITION IS INSIDE CHUNK
                        if (cornerLocalX >= 0 && cornerLocalX < width &&
                            cornerLocalY >= 0 && cornerLocalY < height &&
                            cornerLocalZ >= 0 && cornerLocalZ < width)
                        {
                            // std::cout << "corner local: " << cornerLocalX << " " << cornerLocalY << " " << cornerLocalZ << std::endl;

                            // IF DIST FROM SNAP POS TO CORNER POS <= RADIUS
                            float distance = glm::distance(glm::vec3(snapWorldX, snapWorldY, snapWorldZ), glm::vec3(x, y, z));
                            if (distance <= radius) 
                            {
                                int densityIndex = GetDensityIndex(cornerLocalX, cornerLocalY, cornerLocalZ);
                                chunk.densities[densityIndex] += amount / distance;
                                chunk.regenerate = true;
                            }
                        }
                    }
                }
            }
        }
    }

private:
    TerrainGPU terrainGPU;
    std::vector<Chunk> chunks;

    int renderDistanceH = 9;
    int renderDistanceV = 7;
    int width = 12;
    int height = 12;

    int GetDensityIndex(int x, int y, int z) {
        return x + (y * (width + 1)) + (z * (width + 1) * (height + 1));
    }

    int WorldToChunkCorner(int displacement, int dimension) {
        int offset = (dimension / 2);
        int result = (displacement + offset) % (dimension);
        if (result < 0) result += dimension;
        return result;
    }
};